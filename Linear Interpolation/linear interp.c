/*linear interp.c
    Linear Interpolation Routines
	
	These routines were written, primarily, for low performance processors
	such as the ATMega which is both slow and can't do division
	The data is scaled to fit the table axis.
	
	Author: James Holland
	Date:  21st January 2021
	version: 0.1 -  only single ended conversions supported
*/

#include <stdint.h>

/* forward declarations */
uint16_t Interp_2d_16x1(uint8_t *tablePtr, uint16_t inputValue);

const uint8_t CTS_Index[16] = { 0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x84, 0x82, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0 };
/* VE table - random data for now */
const uint8_t VE_LUT[16][16] = { 0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0, 
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0,
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0,
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0,
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0, 
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0,
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0,
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0,
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0, 
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0,
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0,
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0,
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0, 
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0,
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0,
							0x1A, 0x1D, 0x22, 0x2A, 0x35, 0x44, 0x56, 0x6A, 0x7F, 0x93, 0xA6, 0xB6, 0xC4, 0xCF, 0xD8, 0xE0 };

int main()
{
   uint16_t inputValue = 0xF9;
   uint16_t outputValue;
   
   outputValue = Interp_2d_16x1(CTS_Index, inputValue << 4);

   printf("Output value uQ8.8 = 0x%x\n", outputValue);               
   printf("Output value u8 = 0x%x\n", (outputValue >> 8));        
   return 0;
}

uint16_t Interp_2d_16x1(uint8_t *tablePtr, uint16_t inputValue)
{
    /* 2d table interpolation 
    the inputValue should be scaled to an 12bit value for a 1x16 table 
    returns a 16-bit UQ8.8 value*/
    
    uint16_t indexValue, mantissa;
    uint16_t outputValue;
    
    indexValue = inputValue >> 8;			// compiler will optimise this to a virtual shift
    mantissa =  inputValue &= 0x00FF;       // it may optimise this
    if(indexValue==15){                     // special case for last cell
        outputValue = (tablePtr[indexValue] << 8) +((tablePtr[(indexValue)] - tablePtr[indexValue-1]) * mantissa);
    }
    else{                                   // normal case
        outputValue = (tablePtr[indexValue] << 8) +((tablePtr[(indexValue+1)] - tablePtr[indexValue]) * mantissa);
    }
    return outputValue;
}

uint16_t Interp_3d_16x16(uint8_t *tablePtr, uint16_t inputXValue, uint16_t inputYValue)
{
    // Input values should be passed scaled to 12-bits
    
    uint16_t indexYValue, Ymantissa;
    uint16_t X1Value, X2Value;
    uint16_t outputValue;
    
    indexYValue = inputYValue >> 8;
    Ymantissa = inputYValue &= 0x00FF;

    uint8_t *rowPtr = tablePtr + (indexYValue * 16);       // row pointer = table address + (row * columns)
    
    // interpolate first row
    X1Value = Interp_2d_16x1(rowPtr, inputXValue << 4);
    // interpolate second row
    X2Value = Interp_2d_16x1((rowPtr+16), inputXValue << 4);
    // interpolate between values
    outputValue = X1Value + ((X2Value - X1Value) * Ymantissa);
    
    return outputValue;
}