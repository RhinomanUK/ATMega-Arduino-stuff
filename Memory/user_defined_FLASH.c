/*
 * testStuff.c
 *
 * test read and write to a user defined flash section in upper Flash
 * a far pointer must be used because the GCC native pointer is only 16 bits!!!!
 * define the memory section under:
 *		project properties->AVR/GNU linker->Memory sections
 *
 * GCC is weird - a memory section defined at 0x1C0000 appears
 * at 0x38000 in prog FLASH
 *
 * Created: 06/06/2023 09:36:45
 * Author : jholland
 */ 



#include <stdint.h>

#include "avr/pgmspace.h"
#include <avr/io.h>


#define TMEM __attribute__ ((section (".FLASH_TUNE")))


struct table_18x9
{
	uint8_t XMin;
	uint8_t XMax;
	uint8_t XMult;
	uint8_t Columns;
	uint8_t YMin;
	uint8_t YMax;
	uint8_t YMult;
	uint8_t Data[18][9];
};


const struct table_18x9 TMEM testLUT =
{
	0x88,
	0x90,
	0x98,
	0x09,
	0x25,
	0x00,
	0x00,
	{ { 0xB1, 0x90, 0x8C, 0x48, 0x51, 0x5C, 0x58, 0x5B, 0x80 },
	{ 0xB1, 0x5B, 0x5C, 0x65, 0x61, 0x6A, 0x65, 0x7E, 0x70 },
	{ 0x24, 0x6C, 0x6E, 0x78, 0x78, 0x80, 0x7C, 0x78, 0x74 },
	{ 0x3C, 0x72, 0x80, 0x82, 0x7C, 0x84, 0x80, 0x80, 0x7C },
	{ 0x43, 0x78, 0x84, 0x88, 0x84, 0x8C, 0x88, 0x8C, 0x88 },
	{ 0x74, 0x80, 0x88, 0x88, 0x84, 0x88, 0x82, 0x82, 0x7C },
	{ 0x78, 0x88, 0x90, 0x90, 0x8C, 0x8A, 0x86, 0x86, 0x82 },
	{ 0x78, 0x8C, 0x94, 0x94, 0x88, 0x96, 0x92, 0x90, 0x90 },
	{ 0x7C, 0x88, 0x90, 0x90, 0x8C, 0x92, 0x8A, 0x8A, 0x94 },
	{ 0x78, 0x88, 0x94, 0x8C, 0x8A, 0x90, 0x8E, 0x8A, 0x88 },
	{ 0x74, 0x84, 0x90, 0x8C, 0x88, 0x88, 0x8A, 0x86, 0x8C },
	{ 0x66, 0x84, 0x8A, 0x84, 0x82, 0x88, 0x84, 0x80, 0x86 },
	{ 0xE8, 0xB2, 0xA6, 0x9C, 0x94, 0x9C, 0x97, 0x8B, 0x9C },
	{ 0xF6, 0xAE, 0xAF, 0xA7, 0x9B, 0xA4, 0x9B, 0xA5, 0xA4 },
	{ 0xF6, 0x95, 0x9E, 0x98, 0x90, 0xAF, 0x88, 0x86, 0x80 },
	{ 0xF6, 0x95, 0x9E, 0x98, 0x90, 0xAF, 0x88, 0x86, 0x80 },
	{ 0xF6, 0x95, 0x9E, 0x98, 0x90, 0xAF, 0x88, 0x86, 0x80 },
	{ 0xF6, 0x95, 0x9E, 0x98, 0x90, 0xAF, 0x88, 0x86, 0x80 } }
};


const struct table_18x9 testMAP;

volatile uint8_t testByte1;
volatile uint8_t testByte2;
volatile uint8_t testByte3;



void copyU8FromFlash(uint8_t *dest, uint32_t src, uint16_t size)
{
	/* because we need to use a 32-bit address we need to manually copy the data
		use the sizeof the RAM section to avoid overrunning memory in the event of a 
		size mismatch !! */
	
	do 
	{
		*dest = pgm_read_byte_far( src );
		dest++;
		src++;
		size--;
	} while (size);
	
}


int main(void)
{
	
	uint32_t far_testAddress;			/* not a real pointer but will contain the 24-bit address */
	
	
	// simple way to retrieve a byte
		
	testByte1 = pgm_read_byte_far( pgm_get_far_address(testLUT.XMin) );
	testByte2 = pgm_read_byte_far( pgm_get_far_address(testLUT.YMin) );
	testByte3 = pgm_read_byte_far( pgm_get_far_address(testLUT.Data[4][8]) );
	
	
	/* or use a 'pointer' */
	far_testAddress = pgm_get_far_address(testLUT.Data[5][8]);
	
	while(1)
	{
		testByte3 = pgm_read_byte_far( far_testAddress );
		
		far_testAddress = pgm_get_far_address(testLUT);
		
		copyU8FromFlash( &(testMAP), far_testAddress, sizeof(testMAP));
		
		
			
	} // end while

} //end main